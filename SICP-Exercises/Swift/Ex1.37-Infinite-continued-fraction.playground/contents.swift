import Cocoa

// Exercise 1.37
// An infinite continued fraction is an expression of the form
//
//            N1
// f = ------------------
//     D1 +      N2
//          -------------
//          D2 +    N3
//               --------
//               D3 + ...
//
// As an example, the inifinite continued fraction expansion with the Ni and Di all equal to 1 produces 1 / Golden Ratio.
//
// One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation -- a so-called k-term finitie continued fraction -- has the form
//
//            N1
// f = ------------------
//     D1 +      N2
//          -------------
//          D2 +    NK
//               --------
//                  DK
//
// Suppose that n and d are procedures of one argument (the term i) that return the Ni and Di of the terms of the continued fraction. Define a procedure cont-frac such that evaluating (cont-frac n d k) computes the value of the k-term finite continued fraction. Check your procedure by approximating 1 / Golden ratio

func kFiniteContFrac(_ N:@escaping (Int)->Double, _ D:@escaping (Int)->Double, _ k:Int) -> Double {
    func contFrac(i: Int) -> Double {
        if i > k {
            return 0.0
        } else {
            return N(i) / (D(i) + contFrac(i: i + 1))
        }
    }
    return contFrac(i: 1)
}

func goldenRation() -> Double {
    func N(_ i:Int) -> Double {
        return 1.0
    }
    func D(_ i:Int) -> Double {
        return 1.0
    }
    
    return 1 / kFiniteContFrac(N, D, 100)
}
goldenRation()

// How large must k be in order to get an approximation that is accurate to 4 decimal places?
// k needs to be 13 or higher


// b) Write an iterative version of cont-frac
func kFiniteContFracIter(_ N:@escaping (Int)->Double, _ D:@escaping (Int)->Double, _ k:Int) -> Double {
    func contFrac(i: Int, output:Double) -> Double {
        if i == 0 {
            return output
        } else {
            return contFrac(i: i - 1, output: N(i) / (D(i) + output))
        }
    }
    return contFrac(i: k, output: 0.0)
}

func goldenRationIter() -> Double {
    func N(_ i:Int) -> Double {
        return 1.0
    }
    func D(_ i:Int) -> Double {
        return 1.0
    }
    
    return 1 / kFiniteContFracIter( N, D, 100)
}
goldenRationIter()


